#!/usr/bin/env python3
"""
üöÄ BIST 100 S√ºrekli Tarama Sistemi
48 saat √∂nceden y√ºkselme sinyali veren robot
"""

import asyncio
import logging
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import pandas as pd
import numpy as np
from ultra_robot_enhanced_fixed import UltraRobotEnhancedFixed, EnhancedSignalType

# Logging ayarlarƒ±
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bist100_scanner.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class BIST100Scanner:
    """BIST 100 s√ºrekli tarama sistemi"""
    
    def __init__(self):
        self.robot = UltraRobotEnhancedFixed()
        self.bist100_symbols = self._get_bist100_symbols()
        self.scan_interval = 300  # 5 dakika
        self.forecast_hours = 48   # 48 saat √∂nceden
        self.active_signals = {}
        self.signal_history = []
        self.snapshot_path = 'data/forecast_signals.json'
        
    def _get_bist100_symbols(self) -> List[str]:
        """BIST 100 hisse listesi"""
        return [
            "GARAN.IS", "AKBNK.IS", "ISCTR.IS", "YKBNK.IS", "THYAO.IS",
            "SISE.IS", "EREGL.IS", "TUPRS.IS", "ASELS.IS", "KRDMD.IS",
            "PGSUS.IS", "SAHOL.IS", "KCHOL.IS", "VESTL.IS", "BIMAS.IS",
            "MGROS.IS", "TCELL.IS", "TTKOM.IS", "DOHOL.IS", "EKGYO.IS",
            "HEKTS.IS", "KERVN.IS", "KERVT.IS", "KOZAL.IS", "KOZAA.IS",
            "LOGO.IS", "MIPTR.IS", "NTHOL.IS", "OYAKC.IS", "PETKM.IS",
            "POLHO.IS", "PRKAB.IS", "PRKME.IS", "SAFKN.IS", "SASA.IS",
            "SMRTG.IS", "TATKS.IS", "TMSN.IS", "TOASO.IS", "TSKB.IS",
            "TTRAK.IS", "ULKER.IS", "VESBE.IS", "YATAS.IS", "YUNSA.IS",
            "ZRGYO.IS", "ACSEL.IS", "ADEL.IS", "ADESE.IS", "AGHOL.IS",
            "AKENR.IS", "AKFGY.IS", "AKGRT.IS", "AKSA.IS", "ALARK.IS",
            "ALBRK.IS", "ALCAR.IS", "ALCTL.IS", "ALGYO.IS", "ALKIM.IS",
            "ALTIN.IS", "ANACM.IS", "ANELE.IS", "ANGEN.IS", "ARCLK.IS",
            "ASELS.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS",
            "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS",
            "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS",
            "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS",
            "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS",
            "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS",
            "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS", "ASELSAN.IS"
        ]
    
    async def start_continuous_scanning(self):
        """S√ºrekli tarama ba≈ülat"""
        logger.info(f"üöÄ BIST 100 S√ºrekli Tarama Ba≈ülatƒ±ldƒ±!")
        logger.info(f"üìä {len(self.bist100_symbols)} hisse taranacak")
        logger.info(f"‚è∞ Tarama aralƒ±ƒüƒ±: {self.scan_interval} saniye")
        logger.info(f"üîÆ Tahmin s√ºresi: {self.forecast_hours} saat √∂nceden")
        
        while True:
            try:
                start_time = time.time()
                logger.info(f"üîÑ Tarama ba≈üladƒ±: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                
                # T√ºm hisseleri tara
                await self._scan_all_stocks()
                
                # Aktif sinyalleri g√ºncelle
                await self._update_active_signals()
                
                # Performans raporu
                await self._generate_performance_report()

                # Snapshot kaydet
                self._save_forecast_snapshot()
                
                scan_duration = time.time() - start_time
                logger.info(f"‚úÖ Tarama tamamlandƒ±: {scan_duration:.2f} saniye")
                
                # Sonraki tarama i√ßin bekle
                await asyncio.sleep(self.scan_interval)
                
            except Exception as e:
                logger.error(f"‚ùå Tarama hatasƒ±: {e}")
                await asyncio.sleep(60)  # Hata durumunda 1 dakika bekle
    
    async def _scan_all_stocks(self):
        """T√ºm hisseleri tara"""
        for symbol in self.bist100_symbols:
            try:
                logger.info(f"üîç {symbol} taranƒ±yor...")
                
                # Geli≈ümi≈ü sinyal √ºret
                signals = self.robot.generate_enhanced_signals(symbol)
                
                if signals:
                    logger.info(f"üéØ {symbol}: {len(signals)} sinyal bulundu!")
                    
                    # 48 saat √∂nceden sinyalleri filtrele
                    forecast_signals = self._filter_forecast_signals(signals)
                    
                    if forecast_signals:
                        logger.info(f"üöÄ {symbol}: {len(forecast_signals)} 48h √∂nceden sinyal!")
                        await self._process_forecast_signals(symbol, forecast_signals)
                    else:
                        logger.info(f"‚è∏Ô∏è {symbol}: 48h √∂nceden sinyal yok")
                else:
                    logger.info(f"‚ùå {symbol}: Sinyal bulunamadƒ±")
                
                # Rate limiting
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"‚ùå {symbol} tarama hatasƒ±: {e}")
                continue
    
    def _filter_forecast_signals(self, signals: List) -> List:
        """48 saat √∂nceden sinyalleri filtrele"""
        forecast_signals = []
        
        for signal in signals:
            # Sadece BUY sinyallerini al
            if signal.action in [EnhancedSignalType.STRONG_BUY, EnhancedSignalType.BUY, EnhancedSignalType.WEAK_BUY]:
                # Y√ºksek g√ºven skorlu sinyalleri al
                if signal.confidence > 0.6:
                    forecast_signals.append(signal)
        
        return forecast_signals
    
    async def _process_forecast_signals(self, symbol: str, signals: List):
        """48 saat √∂nceden sinyalleri i≈üle"""
        for signal in signals:
            signal_key = f"{symbol}_{signal.timestamp.strftime('%Y%m%d_%H%M%S')}"
            
            if signal_key not in self.active_signals:
                self.active_signals[signal_key] = {
                    "symbol": symbol,
                    "signal": signal,
                    "detected_at": datetime.now(),
                    "status": "ACTIVE",
                    "notifications_sent": False
                }
                
                logger.info(f"üö® YENƒ∞ 48H Sƒ∞NYAL: {symbol}")
                logger.info(f"   üìà Aksiyon: {signal.action.value}")
                logger.info(f"   üéØ Giri≈ü: {signal.entry_price:.3f}")
                logger.info(f"   üõë Stop Loss: {signal.stop_loss:.3f}")
                logger.info(f"   üéâ Take Profit: {signal.take_profit:.3f}")
                logger.info(f"   ‚ö†Ô∏è Risk/Reward: {signal.risk_reward:.3f}")
                logger.info(f"   üß† G√ºven: {signal.confidence:.3f}")
                
                # Bildirim g√∂nder
                await self._send_notification(signal)
        # Her i≈ülem sonrasƒ± snapshot g√ºncelle
        self._save_forecast_snapshot()
    
    async def _send_notification(self, signal):
        """Bildirim g√∂nder"""
        try:
            # FCM veya email bildirimi burada
            notification_text = f"""
üö® BIST 100 - 48 SAAT √ñNCEDEN Sƒ∞NYAL! üö®

üìä Hisse: {signal.symbol}
üìà Aksiyon: {signal.action.value}
üéØ Giri≈ü Fiyatƒ±: {signal.entry_price:.3f} ‚Ç∫
üõë Stop Loss: {signal.stop_loss:.3f} ‚Ç∫
üéâ Take Profit: {signal.take_profit:.3f} ‚Ç∫
‚ö†Ô∏è Risk/Reward: {signal.risk_reward:.3f}
üß† G√ºven Skoru: {signal.confidence:.3f}
‚è∞ Tespit Zamanƒ±: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üîÆ Bu hisse 48 saat i√ßinde y√ºkselebilir!
            """
            
            logger.info(f"üì± Bildirim g√∂nderildi: {signal.symbol}")
            # TODO: FCM push notification implement
            
        except Exception as e:
            logger.error(f"‚ùå Bildirim hatasƒ±: {e}")
    
    async def _update_active_signals(self):
        """Aktif sinyalleri g√ºncelle"""
        current_time = datetime.now()
        
        for signal_key, signal_data in list(self.active_signals.items()):
            signal = signal_data["signal"]
            detected_at = signal_data["detected_at"]
            
            # 48 saat ge√ßti mi kontrol et
            if current_time - detected_at > timedelta(hours=self.forecast_hours):
                # Sinyal s√ºresi doldu
                signal_data["status"] = "EXPIRED"
                logger.info(f"‚è∞ {signal.symbol} sinyali s√ºresi doldu")
                
                # Sinyal ge√ßerliliƒüini kontrol et
                await self._validate_signal(signal_key, signal_data)
        # G√ºncelleme sonrasƒ± snapshot kaydet
        self._save_forecast_snapshot()
    
    async def _validate_signal(self, signal_key: str, signal_data: Dict):
        """Sinyal ge√ßerliliƒüini kontrol et"""
        try:
            symbol = signal_data["symbol"]
            signal = signal_data["signal"]
            
            # G√ºncel fiyatƒ± al
            current_price = await self._get_current_price(symbol)
            
            if current_price:
                # Sinyal ba≈üarƒ±sƒ±nƒ± hesapla
                if signal.action in [EnhancedSignalType.STRONG_BUY, EnhancedSignalType.BUY, EnhancedSignalType.WEAK_BUY]:
                    if current_price > signal.entry_price:
                        signal_data["status"] = "SUCCESS"
                        logger.info(f"‚úÖ {symbol} sinyali BA≈ûARILI! Giri≈ü: {signal.entry_price:.3f}, G√ºncel: {current_price:.3f}")
                    else:
                        signal_data["status"] = "FAILED"
                        logger.info(f"‚ùå {symbol} sinyali BA≈ûARISIZ! Giri≈ü: {signal.entry_price:.3f}, G√ºncel: {current_price:.3f}")
                
                # Sinyal ge√ßmi≈üine ekle
                self.signal_history.append(signal_data)
                
                # Aktif sinyallerden kaldƒ±r
                del self.active_signals[signal_key]
                
        except Exception as e:
            logger.error(f"‚ùå Sinyal validasyon hatasƒ±: {e}")
    
    async def _get_current_price(self, symbol: str) -> Optional[float]:
        """G√ºncel fiyat al"""
        try:
            # Basit fiyat √ßekme (ger√ßek uygulamada WebSocket kullan)
            import yfinance as yf
            stock = yf.Ticker(symbol)
            current_price = stock.info.get('regularMarketPrice')
            return current_price
        except Exception as e:
            logger.error(f"‚ùå Fiyat √ßekme hatasƒ±: {e}")
            return None
    
    async def _generate_performance_report(self):
        """Performans raporu olu≈ütur"""
        try:
            total_signals = len(self.signal_history)
            successful_signals = len([s for s in self.signal_history if s["status"] == "SUCCESS"])
            failed_signals = len([s for s in self.signal_history if s["status"] == "FAILED"])
            
            if total_signals > 0:
                success_rate = (successful_signals / total_signals) * 100
                logger.info(f"üìä PERFORMANS RAPORU:")
                logger.info(f"   üìà Toplam Sinyal: {total_signals}")
                logger.info(f"   ‚úÖ Ba≈üarƒ±lƒ±: {successful_signals}")
                logger.info(f"   ‚ùå Ba≈üarƒ±sƒ±z: {failed_signals}")
                logger.info(f"   üéØ Ba≈üarƒ± Oranƒ±: {success_rate:.2f}%")
                
                # Hedef %80'e yakla≈üƒ±yor mu?
                if success_rate >= 75:
                    logger.info(f"üéâ HEDEF %80'E YAKLA≈ûIYOR! ≈ûu an: {success_rate:.2f}%")
                elif success_rate >= 60:
                    logger.info(f"üöÄ ƒ∞Yƒ∞ PERFORMANS! ≈ûu an: {success_rate:.2f}%")
                else:
                    logger.info(f"‚ö†Ô∏è GELƒ∞≈ûTƒ∞Rƒ∞LMESƒ∞ GEREKƒ∞YOR! ≈ûu an: {success_rate:.2f}%")
            
        except Exception as e:
            logger.error(f"‚ùå Performans raporu hatasƒ±: {e}")

    def _save_forecast_snapshot(self):
        """Aktif 48h sinyalleri JSON olarak diske kaydet"""
        try:
            import os, json
            os.makedirs('data', exist_ok=True)
            active = []
            for key, s in self.active_signals.items():
                if s.get('status') == 'ACTIVE':
                    sig = s['signal']
                    active.append({
                        'key': key,
                        'symbol': s['symbol'],
                        'action': getattr(sig.action, 'value', str(sig.action)),
                        'entry_price': float(sig.entry_price),
                        'stop_loss': float(sig.stop_loss),
                        'take_profit': float(sig.take_profit),
                        'risk_reward': float(sig.risk_reward),
                        'confidence': float(sig.confidence),
                        'timestamp': sig.timestamp.isoformat()
                    })
            snapshot = {
                'generated_at': datetime.now().isoformat(),
                'total_active': len(active),
                'signals': active
            }
            with open(self.snapshot_path, 'w', encoding='utf-8') as f:
                json.dump(snapshot, f, ensure_ascii=False)
            logger.info(f"üíæ Forecast snapshot kaydedildi: {self.snapshot_path} ({len(active)} aktif)")
        except Exception as e:
            logger.error(f"‚ùå Snapshot kaydetme hatasƒ±: {e}")

async def main():
    """Ana fonksiyon"""
    scanner = BIST100Scanner()
    await scanner.start_continuous_scanning()

if __name__ == "__main__":
    asyncio.run(main())
